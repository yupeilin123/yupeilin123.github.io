<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>青蛙蛤蟆兽</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-13T06:53:47.073Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yupeilin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Koa系列-Vhost：koa-virtual-host</title>
    <link href="http://yoursite.com/2018/11/13/koa/koa-virtual-host/"/>
    <id>http://yoursite.com/2018/11/13/koa/koa-virtual-host/</id>
    <published>2018-11-13T06:29:52.000Z</published>
    <updated>2018-11-13T06:53:47.073Z</updated>
    
    <content type="html"><![CDATA[<p>该中间件是讲述如果在Koa上开启虚拟主机。</p><p>提供字符串，正则，数组及对象进行每个应用进行匹配。以及确保hostname的正确性。</p><p>会通过 <code>koa-compose</code> 来确保每个koa应用中间件的正确调用。</p><p>如果程序执行中出现错误，会报错。</p><p>起初还不理解使用，然后经过手动去执行应用，才恍然大悟。原来如此。</p><p>接着去看源代码，发现作者写的也是简单的，但这种思路需要我去学习。</p><p>至于如何正确使用这个模块，个人觉得当需要使用不同形式的相同ip，并且每个主机执行些不同中间件时可能会需要。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;该中间件是讲述如果在Koa上开启虚拟主机。&lt;/p&gt;
&lt;p&gt;提供字符串，正则，数组及对象进行每个应用进行匹配。以及确保hostname的正确性。&lt;/p&gt;
&lt;p&gt;会通过 &lt;code&gt;koa-compose&lt;/code&gt;
        
      
    
    </summary>
    
      <category term="Koa" scheme="http://yoursite.com/categories/Koa/"/>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>每周npm模块源码解读：ms</title>
    <link href="http://yoursite.com/2018/11/07/npm/ms/"/>
    <id>http://yoursite.com/2018/11/07/npm/ms/</id>
    <published>2018-11-07T03:20:20.000Z</published>
    <updated>2018-11-07T04:45:51.158Z</updated>
    
    <content type="html"><![CDATA[<p><strong>周2018.11.5 ~ 2018.11.11</strong></p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>模块名：<code>ms</code></p><p>github: <a href="https://github.com/zeit/ms" target="_blank" rel="noopener">https://github.com/zeit/ms</a></p><p>描述：方便的转化将各种时间转化为毫秒，也可以将毫秒转化为其他时间</p><p>适合人群：至少看过一遍源码</p><a id="more"></a><h5 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h5><p>有两个参数，第一个是需要转化的值val，第二个是配置选项options。</p><p>首先判断val的类型，如果是字符串并且长度大于0，就执行函数 <code>parse</code>。如果是数字并且不是NaN，接着判断options.long是否为true，如果为true，就执行函数 <code>fmtLong</code> ，否则执行函数 <code>fmtShot</code>。</p><p>函数 <code>parse</code> ：用正则来匹配val出结果，然后通过 <code>switch case</code> ，返回最终毫秒数。</p><p>函数 <code>fmtShort</code> ：首先通过 <code>Math.abs</code> 返回val的绝对值，然后判断是大于天的毫秒数，还是大于小时的毫秒数等的判断，最终返回正确的值。</p><p>函数 <code>fmtLong</code> ：和函数 <code>fmtShort</code> 一样，区别于改变了后缀词以及判断是否为复数。</p><h5 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h5><p>学习到了，简单，但感觉看这个源码很舒服。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;周2018.11.5 ~ 2018.11.11&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;模块名：&lt;code&gt;ms&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/zeit/ms&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zeit/ms&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;描述：方便的转化将各种时间转化为毫秒，也可以将毫秒转化为其他时间&lt;/p&gt;
&lt;p&gt;适合人群：至少看过一遍源码&lt;/p&gt;
    
    </summary>
    
      <category term="npm" scheme="http://yoursite.com/categories/npm/"/>
    
    
      <category term="NPM" scheme="http://yoursite.com/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>Koa系列-Rate Limiting：koa-ratelimit</title>
    <link href="http://yoursite.com/2018/11/06/koa/koa-ratelimit/"/>
    <id>http://yoursite.com/2018/11/06/koa/koa-ratelimit/</id>
    <published>2018-11-06T05:51:07.000Z</published>
    <updated>2018-11-07T03:19:54.964Z</updated>
    
    <content type="html"><![CDATA[<p>该中间件是用来控制api请求的速率限制，用于数据库 <code>redis</code> ，基于模块 <code>ratelimiter</code> 。</p><p>关于 <code>Rate Limits</code> 有三个响应头，分别是：</p><p><code>X-RateLimit-Remaining</code> ：当前速率限制窗口中的剩余请求数。</p><p><code>X-RateLimit-Reset</code> ：当前速率限制窗口在UTC世界标准时中的重置时间。</p><p><code>X-RateLimit-Limit</code> ：允许用户每小时的最大请求数。</p><a id="more"></a><p>有两个比较重要的配置选择， <code>id</code> 主要是用来区分用户，默认以用户ip作为区分，另外一个是 <code>db</code> ，是数据库 <code>redis</code> 的实例。</p><p>当实例 <code>ratelimiter</code> 并执行其方法时，会返回一个对象，包含四个属性 <code>total</code> ， <code>remaining</code> ， <code>reset</code> 和 <code>resetMs</code> 。</p><p>当 <code>remaining</code> 为0时，也就是剩余请求数为0时，响应头则添加 <code>Retry-After</code> ，并将状态码设置为429，并返回消息。</p><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://www.fullcontact.com/developer/docs/rate-limits/" target="_blank" rel="noopener">https://www.fullcontact.com/developer/docs/rate-limits/</a><br><a href="https://developer.capsulecrm.com/v1/ratelimit/" target="_blank" rel="noopener">https://developer.capsulecrm.com/v1/ratelimit/</a><br><a href="https://blog.apisyouwonthate.com/what-is-api-rate-limiting-all-about-1819a390ab06" target="_blank" rel="noopener">https://blog.apisyouwonthate.com/what-is-api-rate-limiting-all-about-1819a390ab06</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该中间件是用来控制api请求的速率限制，用于数据库 &lt;code&gt;redis&lt;/code&gt; ，基于模块 &lt;code&gt;ratelimiter&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;关于 &lt;code&gt;Rate Limits&lt;/code&gt; 有三个响应头，分别是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X-RateLimit-Remaining&lt;/code&gt; ：当前速率限制窗口中的剩余请求数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X-RateLimit-Reset&lt;/code&gt; ：当前速率限制窗口在UTC世界标准时中的重置时间。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X-RateLimit-Limit&lt;/code&gt; ：允许用户每小时的最大请求数。&lt;/p&gt;
    
    </summary>
    
      <category term="Koa" scheme="http://yoursite.com/categories/Koa/"/>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>Koa系列-Parameter Validation：koa-context-validator</title>
    <link href="http://yoursite.com/2018/11/05/koa/koa-context-validator/"/>
    <id>http://yoursite.com/2018/11/05/koa/koa-context-validator/</id>
    <published>2018-11-05T05:42:07.000Z</published>
    <updated>2018-11-05T06:39:38.364Z</updated>
    
    <content type="html"><![CDATA[<p>Koa的该类型中间件数量并不是很多，并且没有几个符合要求，目前这个中间件 <code>koa-context-validator</code> 达到要求。</p><p>具体的验证参数是模块 <code>joi</code> 提供的。</p><p>第一个参数 <code>schema</code> 是定义了需要验证的内容。如用post时，可以这么写，验证body中的username和age。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.use(validator(&#123;</span><br><span class="line">  body: object().keys(&#123;</span><br><span class="line">    username: string().required(),</span><br><span class="line">    age: number().required(),</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><a id="more"></a><p>第二个参数 <code>opts_</code> 则是 <code>joi.validate</code> 方法的参数 <code>options</code> 。</p><p>通过 <code>Object.assign</code> 将参数opts_重新复制到另一个变量opts上。然后将ctx和opts.context重新赋值到opts.context上。 </p><p>接着遍历schema，通过函数 <code>isContextOnlyKey</code> 判断是否有key等于 <code>params</code> ,决定需要验证的数据源是 <code>ctx</code> 或者 <code>ctx.request</code> 。</p><p>方法 <code>validate</code> 已经被模块 <code>thenify</code> promiseify了。所以在遍历中，验证每个schema，然后放入到数组中。待遍历结束，通过 <code>Promise.all</code> 来判断每个schema是否已经验证通过。</p><p>关于参数验证的规则，看了 <code>joi</code> 的api文档，所提供的api足够完成常规的参数验证的需求。但个人还是比较喜欢中间件 <code>koa-validate</code> 的用法，可惜该模块只能在Koa_v1中使用。</p><p>业界也有其他比较好的参数验证的模块，如 <code>parameter</code> 等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Koa的该类型中间件数量并不是很多，并且没有几个符合要求，目前这个中间件 &lt;code&gt;koa-context-validator&lt;/code&gt; 达到要求。&lt;/p&gt;
&lt;p&gt;具体的验证参数是模块 &lt;code&gt;joi&lt;/code&gt; 提供的。&lt;/p&gt;
&lt;p&gt;第一个参数 &lt;code&gt;schema&lt;/code&gt; 是定义了需要验证的内容。如用post时，可以这么写，验证body中的username和age。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;app.use(validator(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  body: object().keys(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    username: string().required(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    age: number().required(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Koa" scheme="http://yoursite.com/categories/Koa/"/>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>Koa系列-Body Parsing：koa-bodyparser</title>
    <link href="http://yoursite.com/2018/11/03/koa/koa-bodyparser/"/>
    <id>http://yoursite.com/2018/11/03/koa/koa-bodyparser/</id>
    <published>2018-11-03T06:48:54.000Z</published>
    <updated>2018-11-05T05:45:03.110Z</updated>
    
    <content type="html"><![CDATA[<p>具体的body解析是基于模块 <code>co-body</code> ，而 <code>co-body</code> 是对模块 <code>raw-body</code> 更高级的封装。</p><p>首先是对配置项的操作，如自定义JSON检测函数 <code>detectJSON</code> ，自定义错误处理函数 <code>onerror</code> 等。</p><p>默认接受的请求类型是 <code>json</code> 和 <code>form</code> ，只有在能接受的类型下才可以执行下一步。</p><p>比较重要的一点是将选项 <code>returnRawBody</code> 默认为true且不能修改，是因为要返回的是解析后的值。</p><a id="more"></a><p>接着分别处理 <code>json</code> 、 <code>form</code> 和 <code>text</code> 的配置选项。然后与用户定义的 <code>extendTypes</code> 进行合并。</p><p>最后通过 <code>co-body</code> 进行处理。</p><p>该模块是对 <code>co-body</code> 进行封装以便在koa2中使用。在配置选项上比 <code>co-body</code> 的更加丰富。总体来说比较简单，但还是有疑问在。</p><p>为什么要对 <code>opts.detectJSON</code> ，<code>opts.onerror</code> 赋值给 <code>detectJSON</code> , <code>onerror</code> 之后重新赋值 <code>detectJSON</code> 。是因为后续对 <code>opts</code> 的操作不会不影响这两个函数吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;具体的body解析是基于模块 &lt;code&gt;co-body&lt;/code&gt; ，而 &lt;code&gt;co-body&lt;/code&gt; 是对模块 &lt;code&gt;raw-body&lt;/code&gt; 更高级的封装。&lt;/p&gt;
&lt;p&gt;首先是对配置项的操作，如自定义JSON检测函数 &lt;code&gt;detectJSON&lt;/code&gt; ，自定义错误处理函数 &lt;code&gt;onerror&lt;/code&gt; 等。&lt;/p&gt;
&lt;p&gt;默认接受的请求类型是 &lt;code&gt;json&lt;/code&gt; 和 &lt;code&gt;form&lt;/code&gt; ，只有在能接受的类型下才可以执行下一步。&lt;/p&gt;
&lt;p&gt;比较重要的一点是将选项 &lt;code&gt;returnRawBody&lt;/code&gt; 默认为true且不能修改，是因为要返回的是解析后的值。&lt;/p&gt;
    
    </summary>
    
      <category term="Koa" scheme="http://yoursite.com/categories/Koa/"/>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
</feed>
