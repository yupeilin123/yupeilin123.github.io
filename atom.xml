<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>青蛙蛤蟆兽</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-14T03:46:40.564Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yupeilin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Koa系列-Documentation：koa-joi-swagger</title>
    <link href="http://yoursite.com/2018/12/14/koa/koa-joi-swagger/"/>
    <id>http://yoursite.com/2018/12/14/koa/koa-joi-swagger/</id>
    <published>2018-12-14T03:18:51.000Z</published>
    <updated>2018-12-14T03:46:40.564Z</updated>
    
    <content type="html"><![CDATA[<p>这个中间件主要是用来搭建 api 文档管理的网站，用到了 <code>swagger-ui</code> 作为页面 UI， <code>joi</code> 用做管理 js 对象的验证器。</p><p>首先是用 <code>joi.extend</code> 扩展了对象，字符和数字新的 joi 实例。</p><p>然后选择是用 v3 还是 v2 的 <code>swagger-ui</code> ，得到最终渲染的模板 html。</p><p>最后对描述 api 的内容进行转化，生成验证规则，得到最终的 api 文档管理。</p><p>这个中间件挺老了，并且用法也不太方便，而且现在市面上也出现了挺多优秀的 api 文档管理系统。</p><p>所以就大概就了解其实现思路。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;这个中间件主要是用来搭建 api 文档管理的网站，用到了 &lt;code&gt;swagger-ui&lt;/code&gt; 作为页面 UI， &lt;code&gt;joi&lt;/code&gt; 用做管理 js 对象的验证器。&lt;/p&gt;
&lt;p&gt;首先是用 &lt;code&gt;joi.extend&lt;/code&gt;
        
      
    
    </summary>
    
      <category term="Koa" scheme="http://yoursite.com/categories/Koa/"/>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>每周npm模块源码解读：get-port</title>
    <link href="http://yoursite.com/2018/12/10/npm/get-port/"/>
    <id>http://yoursite.com/2018/12/10/npm/get-port/</id>
    <published>2018-12-10T15:11:15.000Z</published>
    <updated>2018-12-14T03:46:54.162Z</updated>
    
    <content type="html"><![CDATA[<p><strong>周2018.12.10 ~ 2018.12.16</strong></p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>模块名：<code>get-port</code></p><p>github: <a href="https://github.com/sindresorhus/get-port" target="_blank" rel="noopener">https://github.com/sindresorhus/get-port</a></p><p>描述：随即找到一个可用的端口或则检查端口是否可以使用</p><p>适合人群：至少看过一遍源码</p><a id="more"></a><h5 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h5><p>首先根据 <code>option</code> 来判断是判断端口是否可用还是随机得到一个可用的端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = options =&gt; options ?</span><br><span class="line">  getPort(options).catch(() =&gt; getPort(&#123;port: 0&#125;)) :</span><br><span class="line">  getPort(&#123;port: 0&#125;);</span><br></pre></td></tr></table></figure><p><code>options.port</code> 的类型得为数字或者数组，如果不是，也可以进行 <code>getPort({port: 0}))</code> 。</p><p>但会出现一个错误即是 <code>UnhandledPromiseRejectionWarning</code> 。</p><p>最后是通过函数<code>isAvailable</code> 来得到或者判断端口可否使用。</p><p>函数 <code>getPort</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const getPort = (options = &#123;&#125;) =&gt; new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  if (typeof options.port === &apos;number&apos;) &#123;</span><br><span class="line">    options.port = [options.port];</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;!-- 操作端口号 --&gt;</span><br><span class="line">  options.port.reduce((seq, port) =&gt; &#123;</span><br><span class="line">    return seq.catch(() =&gt; &#123;</span><br><span class="line">      return isAvailable(Object.assign(&#123;&#125;, options, &#123;port&#125;))</span><br><span class="line">        .then(port =&gt; port)</span><br><span class="line">        .catch(Promise.reject.bind(Promise));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, Promise.reject()).then(resolve).catch(reject);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h5><p>学习了node模块net的使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;周2018.12.10 ~ 2018.12.16&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;模块名：&lt;code&gt;get-port&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/sindresorhus/get-port&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sindresorhus/get-port&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;描述：随即找到一个可用的端口或则检查端口是否可以使用&lt;/p&gt;
&lt;p&gt;适合人群：至少看过一遍源码&lt;/p&gt;
    
    </summary>
    
      <category term="npm" scheme="http://yoursite.com/categories/npm/"/>
    
    
      <category term="NPM" scheme="http://yoursite.com/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>每周npm模块源码解读：inherits</title>
    <link href="http://yoursite.com/2018/12/06/npm/inherits/"/>
    <id>http://yoursite.com/2018/12/06/npm/inherits/</id>
    <published>2018-12-06T06:02:14.000Z</published>
    <updated>2018-12-07T02:58:58.667Z</updated>
    
    <content type="html"><![CDATA[<p><strong>周2018.12.3 ~ 2018.12.9</strong></p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>模块名：<code>inherits</code></p><p>github: <a href="https://github.com/isaacs/inherits" target="_blank" rel="noopener">https://github.com/isaacs/inherits</a></p><p>描述：一种适用于node和浏览器的继承方法</p><p>适合人群：至少看过一遍源码</p><a id="more"></a><h5 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h5><p>首先是 <code>require(&#39;util&#39;)</code> ,判断 <code>util.inherits</code> 是否为函数（判断是否在node环境），如果是，用此方法。</p><p>如果不是，throw错误，转而使用在浏览器中的继承方法。</p><p>一种是以 <code>Object.create</code> 实现继承（寄生组合式继承），另一种是判断 <code>Object.create</code> 不能使用时的垫片方法，实现 <code>Object.create</code> 的使用（寄生组合式继承）。</p><p><strong>js不同继承方式原理</strong></p><h6 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h6><p>利用原型让一个引用类型继承另一个引用类型的属性和方法</p><h6 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h6><p>在子类型构造函数的内部调用超类型构造函数</p><h6 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h6><p>使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承</p><h6 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h6><p>借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型</p><h6 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h6><p>创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象</p><h6 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h6><p>不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型 的原型</p><h5 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h5><p>可以从中学习javascript的继承方式</p><h5 id="附-util-inherits-源码："><a href="#附-util-inherits-源码：" class="headerlink" title="附 util.inherits 源码："></a>附 <code>util.inherits</code> 源码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function inherits(ctor, superCtor) &#123;</span><br><span class="line"></span><br><span class="line">  if (ctor === undefined || ctor === null)</span><br><span class="line">    throw new ERR_INVALID_ARG_TYPE(&apos;ctor&apos;, &apos;Function&apos;, ctor);</span><br><span class="line"></span><br><span class="line">  if (superCtor === undefined || superCtor === null)</span><br><span class="line">    throw new ERR_INVALID_ARG_TYPE(&apos;superCtor&apos;, &apos;Function&apos;, superCtor);</span><br><span class="line"></span><br><span class="line">  if (superCtor.prototype === undefined) &#123;</span><br><span class="line">    throw new ERR_INVALID_ARG_TYPE(&apos;superCtor.prototype&apos;,</span><br><span class="line">      &apos;Function&apos;, superCtor.prototype);</span><br><span class="line">  &#125;</span><br><span class="line">  Object.defineProperty(ctor, &apos;super_&apos;, &#123;</span><br><span class="line">    value: superCtor,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;);</span><br><span class="line">  Object.setPrototypeOf(ctor.prototype, superCtor.prototype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;周2018.12.3 ~ 2018.12.9&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;模块名：&lt;code&gt;inherits&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/isaacs/inherits&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/isaacs/inherits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;描述：一种适用于node和浏览器的继承方法&lt;/p&gt;
&lt;p&gt;适合人群：至少看过一遍源码&lt;/p&gt;
    
    </summary>
    
      <category term="npm" scheme="http://yoursite.com/categories/npm/"/>
    
    
      <category term="NPM" scheme="http://yoursite.com/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>每周npm模块源码解读：configstore</title>
    <link href="http://yoursite.com/2018/12/04/npm/configstore/"/>
    <id>http://yoursite.com/2018/12/04/npm/configstore/</id>
    <published>2018-12-04T06:24:05.000Z</published>
    <updated>2018-12-04T09:04:00.171Z</updated>
    
    <content type="html"><![CDATA[<p><strong>补周2018.11.26 ~ 2018.12.2</strong></p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>模块名：<code>configstore</code></p><p>github: <a href="https://github.com/yeoman/configstore" target="_blank" rel="noopener">https://github.com/yeoman/configstore</a></p><p>描述：一个能读取和持久化配置的模块</p><p>适合人群：至少看过一遍源码</p><a id="more"></a><h5 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h5><p>类 <code>Configstore</code> 有三个参数 <code>packageName</code> , <code>defaults</code> 和 <code>options</code> 。</p><p><code>packageName</code> 表示记录该实例的一个标记。</p><p><code>defaults</code> 表示初始化默认的配置。</p><p><code>options</code> 表示一些选项配置。</p><p>首先得到存储路径，然后判断是否有 <code>defaults</code> 来初始化默认配置。</p><p>存储路径的判断是根据选项配置，如果定义了 <code>globalConfigPath</code> 为 true,则存储为 <code>packageName/config.json</code> ，否则为 <code>configstore/packageName.json</code> 。</p><p>最后根据 <code>option.configPath</code> 是否存在来判断是采用 <code>configPath</code> 还是默认的路径。</p><p>接着就是将类 <code>Configstore</code> 实例化，有一些实例方法。如set,get,has,delete,clear等方法。</p><p>这些方法主要用到了模块 <code>dot-prop</code> 用作数据操作。</p><h5 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h5><p>可以联想localStorage，sessionStorage的原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;补周2018.11.26 ~ 2018.12.2&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;模块名：&lt;code&gt;configstore&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/yeoman/configstore&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/yeoman/configstore&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;描述：一个能读取和持久化配置的模块&lt;/p&gt;
&lt;p&gt;适合人群：至少看过一遍源码&lt;/p&gt;
    
    </summary>
    
      <category term="npm" scheme="http://yoursite.com/categories/npm/"/>
    
    
      <category term="NPM" scheme="http://yoursite.com/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>每周npm模块源码解读：tz-format</title>
    <link href="http://yoursite.com/2018/11/29/npm/tz-format/"/>
    <id>http://yoursite.com/2018/11/29/npm/tz-format/</id>
    <published>2018-11-28T16:14:13.000Z</published>
    <updated>2018-11-28T16:29:13.493Z</updated>
    
    <content type="html"><![CDATA[<p><strong>补 周2018.11.19 ~ 2018.11.25</strong></p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>模块名：<code>tz-format</code></p><p>github: <a href="https://github.com/samverschueren/tz-format" target="_blank" rel="noopener">https://github.com/samverschueren/tz-format</a></p><p>描述：提供一种UTC时间的转化方法</p><p>适合人群：至少看过一遍源码</p><a id="more"></a><h5 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h5><p>该使用方法提供两个参数，一个是日期 <code>date</code> ，另外一个是UTC时间的偏移量 <code>offset</code> 。</p><p>首先判断 <code>data</code> 和 <code>offset</code> 的数据类型。</p><p>接着用方法 <code>getOffset</code> 得到当前的UTC偏移量。</p><p>然后判断 <code>offset</code> ，去设置 <code>date</code> 的分钟，用 <code>setMinutes</code> 方法，该方法的参数超过了合理范围，会相应的更新日期时间中的时间信息。</p><p>最后返回当前时间。</p><p>并且有一个辅助函数 <code>pad</code> 在参数小与10时添加前置0。</p><h5 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h5><p>具体实现挺简单的，可以去看看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;补 周2018.11.19 ~ 2018.11.25&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;模块名：&lt;code&gt;tz-format&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/samverschueren/tz-format&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/samverschueren/tz-format&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;描述：提供一种UTC时间的转化方法&lt;/p&gt;
&lt;p&gt;适合人群：至少看过一遍源码&lt;/p&gt;
    
    </summary>
    
      <category term="npm" scheme="http://yoursite.com/categories/npm/"/>
    
    
      <category term="NPM" scheme="http://yoursite.com/tags/NPM/"/>
    
  </entry>
  
</feed>
