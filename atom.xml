<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>青蛙蛤蟆兽</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-07T02:58:58.667Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yupeilin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每周npm模块源码解读：inherits</title>
    <link href="http://yoursite.com/2018/12/06/npm/inherits/"/>
    <id>http://yoursite.com/2018/12/06/npm/inherits/</id>
    <published>2018-12-06T06:02:14.000Z</published>
    <updated>2018-12-07T02:58:58.667Z</updated>
    
    <content type="html"><![CDATA[<p><strong>周2018.12.3 ~ 2018.12.9</strong></p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>模块名：<code>inherits</code></p><p>github: <a href="https://github.com/isaacs/inherits" target="_blank" rel="noopener">https://github.com/isaacs/inherits</a></p><p>描述：一种适用于node和浏览器的继承方法</p><p>适合人群：至少看过一遍源码</p><a id="more"></a><h5 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h5><p>首先是 <code>require(&#39;util&#39;)</code> ,判断 <code>util.inherits</code> 是否为函数（判断是否在node环境），如果是，用此方法。</p><p>如果不是，throw错误，转而使用在浏览器中的继承方法。</p><p>一种是以 <code>Object.create</code> 实现继承（寄生组合式继承），另一种是判断 <code>Object.create</code> 不能使用时的垫片方法，实现 <code>Object.create</code> 的使用（寄生组合式继承）。</p><p><strong>js不同继承方式原理</strong></p><h6 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h6><p>利用原型让一个引用类型继承另一个引用类型的属性和方法</p><h6 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h6><p>在子类型构造函数的内部调用超类型构造函数</p><h6 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h6><p>使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承</p><h6 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h6><p>借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型</p><h6 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h6><p>创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象</p><h6 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h6><p>不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型 的原型</p><h5 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h5><p>可以从中学习javascript的继承方式</p><h5 id="附-util-inherits-源码："><a href="#附-util-inherits-源码：" class="headerlink" title="附 util.inherits 源码："></a>附 <code>util.inherits</code> 源码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function inherits(ctor, superCtor) &#123;</span><br><span class="line"></span><br><span class="line">  if (ctor === undefined || ctor === null)</span><br><span class="line">    throw new ERR_INVALID_ARG_TYPE(&apos;ctor&apos;, &apos;Function&apos;, ctor);</span><br><span class="line"></span><br><span class="line">  if (superCtor === undefined || superCtor === null)</span><br><span class="line">    throw new ERR_INVALID_ARG_TYPE(&apos;superCtor&apos;, &apos;Function&apos;, superCtor);</span><br><span class="line"></span><br><span class="line">  if (superCtor.prototype === undefined) &#123;</span><br><span class="line">    throw new ERR_INVALID_ARG_TYPE(&apos;superCtor.prototype&apos;,</span><br><span class="line">      &apos;Function&apos;, superCtor.prototype);</span><br><span class="line">  &#125;</span><br><span class="line">  Object.defineProperty(ctor, &apos;super_&apos;, &#123;</span><br><span class="line">    value: superCtor,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;);</span><br><span class="line">  Object.setPrototypeOf(ctor.prototype, superCtor.prototype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;周2018.12.3 ~ 2018.12.9&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;模块名：&lt;code&gt;inherits&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/isaacs/inherits&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/isaacs/inherits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;描述：一种适用于node和浏览器的继承方法&lt;/p&gt;
&lt;p&gt;适合人群：至少看过一遍源码&lt;/p&gt;
    
    </summary>
    
      <category term="npm" scheme="http://yoursite.com/categories/npm/"/>
    
    
      <category term="NPM" scheme="http://yoursite.com/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>每周npm模块源码解读：configstore</title>
    <link href="http://yoursite.com/2018/12/04/npm/configstore/"/>
    <id>http://yoursite.com/2018/12/04/npm/configstore/</id>
    <published>2018-12-04T06:24:05.000Z</published>
    <updated>2018-12-04T09:04:00.171Z</updated>
    
    <content type="html"><![CDATA[<p><strong>补周2018.11.26 ~ 2018.12.2</strong></p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>模块名：<code>configstore</code></p><p>github: <a href="https://github.com/yeoman/configstore" target="_blank" rel="noopener">https://github.com/yeoman/configstore</a></p><p>描述：一个能读取和持久化配置的模块</p><p>适合人群：至少看过一遍源码</p><a id="more"></a><h5 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h5><p>类 <code>Configstore</code> 有三个参数 <code>packageName</code> , <code>defaults</code> 和 <code>options</code> 。</p><p><code>packageName</code> 表示记录该实例的一个标记。</p><p><code>defaults</code> 表示初始化默认的配置。</p><p><code>options</code> 表示一些选项配置。</p><p>首先得到存储路径，然后判断是否有 <code>defaults</code> 来初始化默认配置。</p><p>存储路径的判断是根据选项配置，如果定义了 <code>globalConfigPath</code> 为 true,则存储为 <code>packageName/config.json</code> ，否则为 <code>configstore/packageName.json</code> 。</p><p>最后根据 <code>option.configPath</code> 是否存在来判断是采用 <code>configPath</code> 还是默认的路径。</p><p>接着就是将类 <code>Configstore</code> 实例化，有一些实例方法。如set,get,has,delete,clear等方法。</p><p>这些方法主要用到了模块 <code>dot-prop</code> 用作数据操作。</p><h5 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h5><p>可以联想localStorage，sessionStorage的原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;补周2018.11.26 ~ 2018.12.2&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;模块名：&lt;code&gt;configstore&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/yeoman/configstore&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/yeoman/configstore&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;描述：一个能读取和持久化配置的模块&lt;/p&gt;
&lt;p&gt;适合人群：至少看过一遍源码&lt;/p&gt;
    
    </summary>
    
      <category term="npm" scheme="http://yoursite.com/categories/npm/"/>
    
    
      <category term="NPM" scheme="http://yoursite.com/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>每周npm模块源码解读：tz-format</title>
    <link href="http://yoursite.com/2018/11/29/npm/tz-format/"/>
    <id>http://yoursite.com/2018/11/29/npm/tz-format/</id>
    <published>2018-11-28T16:14:13.000Z</published>
    <updated>2018-11-28T16:29:13.493Z</updated>
    
    <content type="html"><![CDATA[<p><strong>补 周2018.11.19 ~ 2018.11.25</strong></p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>模块名：<code>tz-format</code></p><p>github: <a href="https://github.com/samverschueren/tz-format" target="_blank" rel="noopener">https://github.com/samverschueren/tz-format</a></p><p>描述：提供一种UTC时间的转化方法</p><p>适合人群：至少看过一遍源码</p><a id="more"></a><h5 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h5><p>该使用方法提供两个参数，一个是日期 <code>date</code> ，另外一个是UTC时间的偏移量 <code>offset</code> 。</p><p>首先判断 <code>data</code> 和 <code>offset</code> 的数据类型。</p><p>接着用方法 <code>getOffset</code> 得到当前的UTC偏移量。</p><p>然后判断 <code>offset</code> ，去设置 <code>date</code> 的分钟，用 <code>setMinutes</code> 方法，该方法的参数超过了合理范围，会相应的更新日期时间中的时间信息。</p><p>最后返回当前时间。</p><p>并且有一个辅助函数 <code>pad</code> 在参数小与10时添加前置0。</p><h5 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h5><p>具体实现挺简单的，可以去看看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;补 周2018.11.19 ~ 2018.11.25&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;模块名：&lt;code&gt;tz-format&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/samverschueren/tz-format&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/samverschueren/tz-format&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;描述：提供一种UTC时间的转化方法&lt;/p&gt;
&lt;p&gt;适合人群：至少看过一遍源码&lt;/p&gt;
    
    </summary>
    
      <category term="npm" scheme="http://yoursite.com/categories/npm/"/>
    
    
      <category term="NPM" scheme="http://yoursite.com/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>每周npm模块源码解读：@medv/prettyjson</title>
    <link href="http://yoursite.com/2018/11/14/npm/prettyjson/"/>
    <id>http://yoursite.com/2018/11/14/npm/prettyjson/</id>
    <published>2018-11-14T06:04:00.000Z</published>
    <updated>2018-11-14T06:31:23.736Z</updated>
    
    <content type="html"><![CDATA[<p><strong>周2018.11.12 ~ 2018.11.18</strong></p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>模块名：<code>@medv/prettyjson</code></p><p>github: <a href="https://github.com/antonmedv/prettyjson" target="_blank" rel="noopener">https://github.com/antonmedv/prettyjson</a></p><p>描述：美化JSON格式</p><p>适合人群：至少看过一遍源码</p><a id="more"></a><h5 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h5><p>有两个参数可以输入，第一个是值 <code>v</code>，第二个是缩进的空格。用模块 <code>chalk</code> 输出不同的颜色的值。</p><p>首先判断 <code>v</code> 类型 ：</p><p><code>undefiend</code> ：如果是，返回 <code>void 0</code> ,实则是 <code>undefined</code> 。</p><p>值为 <code>null</code> ： 则返回值。</p><p><code>number</code> 并且使用 <code>Numebr.isFinite</code> 为true：则返回值。</p><p><code>boolean</code>： 如果是，返回值。</p><p><code>string</code>：需要对其进行 <code>JSON.stringify</code> 然后在返回。</p><p><code>array</code> ：使用了 <code>Generator</code> 函数，然后使用递归判断里面的值，并用模块 <code>indent-string</code> 缩进字符串。</p><p><code>object</code> ： 同 <code>array</code> 。</p><p>如果都不能满足以上情况，则使用 <code>JSON.stringify</code>。</p><h5 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h5><p>有以下知识点可以学习到：</p><p><code>void 0</code> 的意思，ES6中Number的新方法，<code>Generator</code> 函数的用法，递归。</p><p>推荐阅读： <a href="https://juejin.im/post/5be5b9f8518825512f58ba0e" target="_blank" rel="noopener">https://juejin.im/post/5be5b9f8518825512f58ba0e</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;周2018.11.12 ~ 2018.11.18&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;模块名：&lt;code&gt;@medv/prettyjson&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/antonmedv/prettyjson&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/antonmedv/prettyjson&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;描述：美化JSON格式&lt;/p&gt;
&lt;p&gt;适合人群：至少看过一遍源码&lt;/p&gt;
    
    </summary>
    
      <category term="npm" scheme="http://yoursite.com/categories/npm/"/>
    
    
      <category term="Npm" scheme="http://yoursite.com/tags/Npm/"/>
    
  </entry>
  
  <entry>
    <title>Koa系列-Vhost：koa-virtual-host</title>
    <link href="http://yoursite.com/2018/11/13/koa/koa-virtual-host/"/>
    <id>http://yoursite.com/2018/11/13/koa/koa-virtual-host/</id>
    <published>2018-11-13T06:29:52.000Z</published>
    <updated>2018-11-13T07:27:38.299Z</updated>
    
    <content type="html"><![CDATA[<p>该中间件是讲述如果在Koa上开启虚拟主机。</p><p>提供字符串，正则，数组及对象进行每个应用进行匹配。以及确保hostname的正确性。并且支持http2。</p><p>会通过 <code>koa-compose</code> 来确保每个koa应用中间件的正确调用。</p><p>如果程序执行中出现错误，会报错。</p><p>起初还不理解使用，然后经过手动去执行应用，才恍然大悟。原来如此。</p><p>接着去看源代码，发现作者写的也是简单的，但这种思路需要我去学习。</p><p>至于如何正确使用这个模块，个人觉得当需要使用不同形式的相同ip，并且每个主机执行些不同中间件时可能会需要。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;该中间件是讲述如果在Koa上开启虚拟主机。&lt;/p&gt;
&lt;p&gt;提供字符串，正则，数组及对象进行每个应用进行匹配。以及确保hostname的正确性。并且支持http2。&lt;/p&gt;
&lt;p&gt;会通过 &lt;code&gt;koa-compose&lt;/code&gt;
        
      
    
    </summary>
    
      <category term="Koa" scheme="http://yoursite.com/categories/Koa/"/>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
</feed>
