<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>青蛙蛤蟆兽</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-20T08:17:45.303Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yupeilin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Koa系列-Caching：koa-etag</title>
    <link href="http://yoursite.com/2019/01/20/koa-etag/"/>
    <id>http://yoursite.com/2019/01/20/koa-etag/</id>
    <published>2019-01-20T07:25:34.000Z</published>
    <updated>2019-01-20T08:17:45.303Z</updated>
    
    <content type="html"><![CDATA[<p>有以下几种情况不能使用 <code>etag</code>：</p><p>1.没有响应实体<br>2.已设置了 <code>etag</code><br>3.http状态码不是 <code>2xx</code><br>4.响应实体是 <code>stream</code> 类型，没有具体路径也不行</p><p>最后是使用了包 <code>etag</code> 生成具体的 <code>etag</code></p><p>参考: <a href="https://www.cnblogs.com/etoah/p/5579622.html" target="_blank" rel="noopener">浏览器缓存</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;有以下几种情况不能使用 &lt;code&gt;etag&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;1.没有响应实体&lt;br&gt;2.已设置了 &lt;code&gt;etag&lt;/code&gt;&lt;br&gt;3.http状态码不是 &lt;code&gt;2xx&lt;/code&gt;&lt;br&gt;4.响应实体是
        
      
    
    </summary>
    
      <category term="Koa" scheme="http://yoursite.com/categories/Koa/"/>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>Koa系列-Compression：koa-compress</title>
    <link href="http://yoursite.com/2019/01/18/koa/koa-compress/"/>
    <id>http://yoursite.com/2019/01/18/koa/koa-compress/</id>
    <published>2019-01-18T03:18:29.000Z</published>
    <updated>2019-01-20T07:25:54.493Z</updated>
    
    <content type="html"><![CDATA[<p>使用该库进行压缩，有以下几个条件，若哪一条不能通过，则不需要进行压缩。</p><p>1.必须得有 <code>body</code><br>2.响应头是否已经发送或者响应是否已经结束<br>3.是否设置了 <code>compress = false</code><br>4.请求方法不能是 <code>HEAD</code><br>5.判断状态码是否不能包含消息体<br>6.响应头是否已经存在 <code>Content-Encoding</code><br>7.筛选响应体的类型<br>8.是否可以设置 <code>acceptsEncodings(&#39;gzip&#39;,&#39;deflate&#39;,&#39;identity&#39;)</code><br>9.内容编码为 <code>identity</code><br>10.响应内容大小是否小与设置值</p><p>最后即使用 <code>gzip</code> or <code>defalte</code> 进行压缩传输。</p><p>参考：<a href="https://blog.csdn.net/u014569188/article/details/78912446" target="_blank" rel="noopener">http协议中的Content-Encoding</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;使用该库进行压缩，有以下几个条件，若哪一条不能通过，则不需要进行压缩。&lt;/p&gt;
&lt;p&gt;1.必须得有 &lt;code&gt;body&lt;/code&gt;&lt;br&gt;2.响应头是否已经发送或者响应是否已经结束&lt;br&gt;3.是否设置了 &lt;code&gt;compress =
        
      
    
    </summary>
    
      <category term="Koa" scheme="http://yoursite.com/categories/Koa/"/>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>Koa系列-JSON and JSONP Responses：koa-response-jsop</title>
    <link href="http://yoursite.com/2019/01/17/koa/koa-response-jsop/"/>
    <id>http://yoursite.com/2019/01/17/koa/koa-response-jsop/</id>
    <published>2019-01-17T03:21:55.000Z</published>
    <updated>2019-01-17T03:34:27.294Z</updated>
    
    <content type="html"><![CDATA[<p>这个库的具体实现是将koa实例传入函数jsonp，在contenxt上挂载一个新函数jsonp，来达到效果。</p><p>参考：<a href="https://segmentfault.com/a/1190000009742074" target="_blank" rel="noopener">jsonp原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;这个库的具体实现是将koa实例传入函数jsonp，在contenxt上挂载一个新函数jsonp，来达到效果。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://segmentfault.com/a/1190000009742074&quot; target=&quot;_blank&quot;
        
      
    
    </summary>
    
      <category term="Koa" scheme="http://yoursite.com/categories/Koa/"/>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>Koa系列-HTTP2：koa-server-push</title>
    <link href="http://yoursite.com/2019/01/13/koa/koa-server-push/"/>
    <id>http://yoursite.com/2019/01/13/koa/koa-server-push/</id>
    <published>2019-01-13T13:35:40.000Z</published>
    <updated>2019-01-13T14:02:27.769Z</updated>
    
    <content type="html"><![CDATA[<p>在使用http2协议的情况下，开启server push之后，server通过X-Associated-Content header（X-开头的header都属于非标准的，自定义header）告知客户端会有新的内容推送过来。在用户第一次打开网站首页的时候，server将资源主动推送过来可以极大的提升用户体验。</p><p>该模板通过默认的文件名去读取内容，或者是设置读取内容的文件名。</p><p>通过设置http head的Link，添加代理。</p><p>参考：<a href="https://github.com/amandakelake/blog/issues/35" target="_blank" rel="noopener">http2的前生今世</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;在使用http2协议的情况下，开启server push之后，server通过X-Associated-Content
        
      
    
    </summary>
    
      <category term="Koa" scheme="http://yoursite.com/categories/Koa/"/>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>每周npm模块源码解读：mz</title>
    <link href="http://yoursite.com/2018/12/27/npm/mz/"/>
    <id>http://yoursite.com/2018/12/27/npm/mz/</id>
    <published>2018-12-27T14:43:13.000Z</published>
    <updated>2018-12-27T15:00:43.100Z</updated>
    
    <content type="html"><![CDATA[<p><strong>周2018.12.24 ~ 2018.12.30</strong></p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>模块名：<code>mz</code></p><p>github: <a href="https://github.com/normalize/mz" target="_blank" rel="noopener">https://github.com/normalize/mz</a></p><p>描述：将node.js的某些模块promisify化</p><p>适合人群：至少看过一遍源码</p><a id="more"></a><h5 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h5><pre><code>现在的node最新稳定版本10.15.0，已经提供了把node模块promisify的函数了。</code></pre><p>将 <code>fs</code>, <code>dns</code>, <code>zlib</code>, <code>crypto</code>, <code>readline</code>, <code>child_process</code> 这些模块的方法promisify化。</p><p>主要是借助 <code>thenify-all</code> 和 <code>any-promise</code> 的帮助。</p><p>有两点需要注意的：</p><p>一个是模块 <code>fs</code> ，重写了 <code>fs.exits</code>。但该方法已经废弃了。该方法实则使用是调用 <code>fs.stat</code>。</p><p>另外一个是模块 <code>readline</code> ，重写了 <code>readline.Interface</code>。兼容以前的版本？覆盖 <code>question</code> ，在这边使用了 <code>promise</code>。</p><h5 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h5><p>在那个年代，把常用的node模块promisfy还是很有用的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;周2018.12.24 ~ 2018.12.30&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;模块名：&lt;code&gt;mz&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/normalize/mz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/normalize/mz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;描述：将node.js的某些模块promisify化&lt;/p&gt;
&lt;p&gt;适合人群：至少看过一遍源码&lt;/p&gt;
    
    </summary>
    
      <category term="npm" scheme="http://yoursite.com/categories/npm/"/>
    
    
      <category term="NPM" scheme="http://yoursite.com/tags/NPM/"/>
    
  </entry>
  
</feed>
