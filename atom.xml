<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>青蛙蛤蟆兽</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-03T07:29:45.144Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yupeilin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Koa系列-Body Parsing：koa-bodyparser</title>
    <link href="http://yoursite.com/2018/11/03/koa/koa-bodyparser/"/>
    <id>http://yoursite.com/2018/11/03/koa/koa-bodyparser/</id>
    <published>2018-11-03T06:48:54.000Z</published>
    <updated>2018-11-03T07:29:45.144Z</updated>
    
    <content type="html"><![CDATA[<p>具体的body解析是基于模块 <code>co-body</code> ，而 <code>co-body</code> 是对模块 <code>raw-body</code> 更高级的封装。</p><p>首先是对配置项的操作，如自定义JSON检测函数 <code>detectJSON</code> ，自定义错误处理函数 <code>onerror</code> 等。</p><p>默认接受的请求类型是 <code>json</code> 和 <code>form</code> ，只有在能接受的类型下才可以执行下一步。</p><p>比较重要的一点是将选项 <code>returnRawBody</code> 默认为true且不能修改，是因为要返回的是解析后的值。</p><p>接着分别处理 <code>json</code> 、 <code>form</code> 和 <code>text</code> 的配置选项。然后与用户定义的 <code>extendTypes</code> 进行合并。</p><p>最后通过 <code>co-body</code> 进行处理。</p><p>该模块是对 <code>co-body</code> 进行封装以便在koa2中使用。在配置选项上比 <code>co-body</code> 的更加丰富。总体来说比较简单，但还是有疑问在。</p><p>为什么要对 <code>opts.detectJSON</code> ，<code>opts.onerror</code> 赋值给 <code>detectJSON</code> , <code>onerror</code> 之后重新赋值 <code>detectJSON</code> 。是因为后续对 <code>opts</code> 的操作不会不影响这两个函数吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;具体的body解析是基于模块 &lt;code&gt;co-body&lt;/code&gt; ，而 &lt;code&gt;co-body&lt;/code&gt; 是对模块 &lt;code&gt;raw-body&lt;/code&gt; 更高级的封装。&lt;/p&gt;
&lt;p&gt;首先是对配置项的操作，如自定义JSON检测函数
        
      
    
    </summary>
    
      <category term="Koa" scheme="http://yoursite.com/categories/Koa/"/>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>每周npm模块源码解读：dateFormat</title>
    <link href="http://yoursite.com/2018/10/31/npm/dateFormat/"/>
    <id>http://yoursite.com/2018/10/31/npm/dateFormat/</id>
    <published>2018-10-31T02:43:38.000Z</published>
    <updated>2018-10-31T06:18:10.742Z</updated>
    
    <content type="html"><![CDATA[<p><strong>周2018.10.29 ~ 2018.11.4</strong></p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>模块名：<code>anywhere</code></p><p>github: <a href="https://github.com/felixge/node-dateformat" target="_blank" rel="noopener">https://github.com/felixge/node-dateformat</a></p><p>描述：以相对较小的size提供了功能更完整的dataFormat</p><p>适合人群：至少看过一遍源码</p><a id="more"></a><h5 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h5><p>主要是通过字符串方法 <code>replace</code> 使用正则来替换字符最后返回值。</p><p>首先定义了三个正则用来替换字符。接着判断参数的类型是否正确。</p><p>然后通过传入的参数是否使用utc或者gmt。接着去定义转化字符的值。</p><p>并且还可以去定义短词字符串来快速执行日期转化以及本地化日名、月名和AM/PM等。</p><h5 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h5><p>没看过其他操作时间的类库，但这个类库的功能还是相对比较完善，最重要的是size很小。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;周2018.10.29 ~ 2018.11.4&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;模块名：&lt;code&gt;anywhere&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/felixge/node-dateformat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/felixge/node-dateformat&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;描述：以相对较小的size提供了功能更完整的dataFormat&lt;/p&gt;
&lt;p&gt;适合人群：至少看过一遍源码&lt;/p&gt;
    
    </summary>
    
      <category term="npm" scheme="http://yoursite.com/categories/npm/"/>
    
    
      <category term="NPM" scheme="http://yoursite.com/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>Koa系列-Security：koa-helmet</title>
    <link href="http://yoursite.com/2018/10/25/koa/koa-helmet/"/>
    <id>http://yoursite.com/2018/10/25/koa/koa-helmet/</id>
    <published>2018-10-25T13:29:18.000Z</published>
    <updated>2018-10-25T15:54:54.499Z</updated>
    
    <content type="html"><![CDATA[<p>主要是通过 npm 包 <code>helemt</code> 来实现开发者的应用程序更加安全。 </p><p><code>helemt</code> 主要是与另一个著名的 node.js Web 应该框架 <code>Express</code> 搭配使用。</p><p>现在是通过一个函数 <code>koaHelmetPromisify</code> 来使用，具体的写法对我来说有点小惊讶，有兴趣的小伙伴可以去看看。</p><p><code>helment</code> 通过设置 Http 头来使应用程序更加安全:</p><p><code>Content-Security-Policy</code> : 内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。(<a href="http://www.ruanyifeng.com/blog/2016/09/csp.html" target="_blank" rel="noopener">参考1</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">参考2</a>)</p><a id="more"></a><p><code>X-DNS-Prefetch-Control</code> : 控制着浏览器的 DNS 预读取功能。 DNS 预读取是一项使浏览器主动去执行域名解析的功能，其范围包括文档的所有链接，无论是图片的，CSS 的，还是 JavaScript 等其他用户能够点击的 URL。(<a href="https://www.cloudxns.net/Support/detail/id/1273.html" target="_blank" rel="noopener">参考1</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Controlling_DNS_prefetching" target="_blank" rel="noopener">参考2</a>、<a href="https://www.jianshu.com/p/c3a14a853c79" target="_blank" rel="noopener">参考3</a>)</p><p><code>Expect-CT</code> : 允许站点选择性报告和/或执行证书透明度 (Certificate Transparency) 要求，来防止错误签发的网站证书的使用不被察觉。当站点启用 Expect-CT 头，就是在请求浏览器检查该网站的任何证书是否出现在公共证书透明度日志之中。(<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expect-CT" target="_blank" rel="noopener">参考1</a>、<a href="https://httpwg.org/http-extensions/expect-ct.html" target="_blank" rel="noopener">参考2</a>)</p><p><code>Feature-Policy</code> : 标头提供了一种机制，允许和拒绝在其自己的框架中以及嵌入的iframe中使用浏览器功能。(<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Feature-Policy" target="_blank" rel="noopener">参考1</a>、<a href="https://developers.google.com/web/updates/2018/06/feature-policy" target="_blank" rel="noopener">参考2</a>、<a href="https://wicg.github.io/feature-policy/#default-allowlists" target="_blank" rel="noopener">参考3</a>)</p><p><code>X-Frame-Options</code> : 用来给浏览器指示允许一个页面可否在frame, &lt; iframe &gt; 或者 &lt; object &gt; 中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。(<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options" target="_blank" rel="noopener">参考</a>)</p><p><code>X-Powered-By</code> : 表明用于支持当前网页应用程序的技术 (例如：PHP)。(<a href="http://www.qttc.net/201306340.html" target="_blank" rel="noopener">参考</a>)</p><p><code>Public-Key-Pins</code> : 是一种安全功能，它告诉 Web 客户端将特定加密公钥与某个 Web 服务器相关联，以降低使用伪造证书进行 MITM 攻击的风险。(<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning" target="_blank" rel="noopener">参考1</a>、<a href="https://imququ.com/post/http-public-key-pinning.html" target="_blank" rel="noopener">参考2</a>)</p><p><code>Strict-Transport-Security</code> : 是一个安全功能，它告诉浏览器只能通过 HTTPS 访问当前资源，而不是 HTTP。(<a href="https://developer.mozilla.org/zh-CN/docs/Security/HTTP_Strict_Transport_Security" target="_blank" rel="noopener">参考1</a>、<a href="https://blog.wilddog.com/?page_id=1493" target="_blank" rel="noopener">参考2</a>、<a href="https://www.cnblogs.com/xiewenming/p/7298893.html" target="_blank" rel="noopener">参考3</a>)</p><p><code>X-Download-Options</code> : 设置 noopen 为阻止 IE8 以上的用户在您的站点上下文中执行下载，指示浏览器不要直接在浏览器中打开下载，而是仅提供“保存”选项。(<a href="https://rorsecurity.info/portfolio/new-http-headers-for-more-security" target="_blank" rel="noopener">参考</a>)</p><p><code>Cache-Control</code> : 通用消息头字段被用于在http 请求和响应中通过指定指令来实现缓存机制。缓存指令是单向的, 这意味着在请求设置的指令，在响应中不一定包含相同的指令。(<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">参考</a>)</p><p><code>Pragma</code> : 是一个在 HTTP/1.0 中规定的通用首部，这个首部的效果依赖于不同的实现，所以在“请求-响应”链中可能会有不同的效果。它用来向后兼容只支持 HTTP/1.0 协议的缓存服务器，与 Cache-Control: no-cache 效果一致。强制要求缓存服务器在返回缓存的版本之前将请求提交到源头服务器进行验证。(<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Pragma" target="_blank" rel="noopener">参考</a>)</p><p><code>Expires</code> : 响应头包含日期/时间， 即在此时候之后，响应过期。(<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires" target="_blank" rel="noopener">参考</a>)</p><p><code>Surrogate-Control</code> : 通过检查来自源服务器的响应中的缓存头来确定要缓存的内容。(<a href="https://www.w3.org/TR/edge-arch/" target="_blank" rel="noopener">参考1</a>、<a href="https://www.nuevocloud.com/documentation/getting-started/cache-headers-cache-control-surrogate-control-and-expires" target="_blank" rel="noopener">参考2</a>)</p><p><code>X-Content-Type-Options</code> : 被服务器用来提示客户端一定要遵循在 Content-Type 首部中对  MIME 类型 的设定，而不能对其进行修改。这就禁用了客户端的 MIME 类型嗅探行。(<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Content-Type-Options" target="_blank" rel="noopener">参考1</a>、<a href="https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/compatibility/gg622941(v=vs.85" target="_blank" rel="noopener">参考2</a>)</p><p><code>X-Permitted-Cross-Domain-Policies</code> : 为Web客户端提供了跨域处理数据的权限 (如Adobe Flash或Adobe Acrobat)。(<a href="http://www.valencynetworks.com/blogs/x-permitted-cross-domain-policies/" target="_blank" rel="noopener">参考</a>)</p><p><code>Referrer-Policy</code> : 首部用来监管哪些访问来源信息，会在 Referer 中发送，应该被包含在生成的请求当中。(<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy" target="_blank" rel="noopener">参考1</a>、<a href="https://linux.cn/article-5808-1.html" target="_blank" rel="noopener">参考2</a>)</p><p><code>X-XSS-Protection</code> : 当检测到跨站脚本攻击 (XSS) 时，浏览器将停止加载页面。(<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-XSS-Protection" target="_blank" rel="noopener">参考1</a>,<a href="http://www.freebuf.com/articles/web/138769.html" target="_blank" rel="noopener">参考2</a>)</p><p>从这么多的 Http 头中看出，使用 <code>helemt</code> 对应用程序的安全性有了极大的保障。但也有一些不是必须的，就可以使用如 <code>helmet.contentSecurityPolicy</code> 单独来设置 Http 头。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是通过 npm 包 &lt;code&gt;helemt&lt;/code&gt; 来实现开发者的应用程序更加安全。 &lt;/p&gt;
&lt;p&gt;&lt;code&gt;helemt&lt;/code&gt; 主要是与另一个著名的 node.js Web 应该框架 &lt;code&gt;Express&lt;/code&gt; 搭配使用。&lt;/p&gt;
&lt;p&gt;现在是通过一个函数 &lt;code&gt;koaHelmetPromisify&lt;/code&gt; 来使用，具体的写法对我来说有点小惊讶，有兴趣的小伙伴可以去看看。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;helment&lt;/code&gt; 通过设置 Http 头来使应用程序更加安全:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt; : 内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。(&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/09/csp.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考1&lt;/a&gt;、&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考2&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="Koa" scheme="http://yoursite.com/categories/Koa/"/>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>每周npm模块源码解读：pify</title>
    <link href="http://yoursite.com/2018/10/23/npm/pify/"/>
    <id>http://yoursite.com/2018/10/23/npm/pify/</id>
    <published>2018-10-23T05:54:37.000Z</published>
    <updated>2018-10-23T06:34:39.202Z</updated>
    
    <content type="html"><![CDATA[<p><strong>周2018.10.22 ~ 2018.10.28</strong></p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>模块名：<code>pify</code></p><p>github: <a href="https://github.com/sindresorhus/pify" target="_blank" rel="noopener">https://github.com/sindresorhus/pify</a></p><p>描述：将回调函数promise化，也就是回调函数可以使用then、catch</p><p>适合人群：至少看过一遍源码</p><a id="more"></a><h5 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h5><p>首先通过 <code>Object.assign</code> 返回新的配置选项，然后判断pify的第一个参数的类型。如类型不正确，则报错。</p><p>如果第一个参数的类型是函数，则创建一个函数，根据 <code>excludeMain</code> 来判断是用它本身自己还是promise化的回调。</p><p>如果第一个参数的类型是对象，则创建一个新的对象，这个对象的原型为这个对象的原型。接着去遍历第一个参数(对象)，通过三表表达式判断对象的每个Key是否为函数和一个筛选函数，如果为true，则将这个函数promise化，否则直接返回该值。</p><p>函数 <code>processFn</code> 就是将回调函数promise化。先创建Promsise函数，然后在其通过配置选项处理参数。最后通过 <code>fn.apply(this.args)</code> 来执行。</p><h5 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h5><p>node中的大部分异步函数可以用模块pify来promise化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;周2018.10.22 ~ 2018.10.28&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;模块名：&lt;code&gt;pify&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/sindresorhus/pify&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sindresorhus/pify&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;描述：将回调函数promise化，也就是回调函数可以使用then、catch&lt;/p&gt;
&lt;p&gt;适合人群：至少看过一遍源码&lt;/p&gt;
    
    </summary>
    
      <category term="npm" scheme="http://yoursite.com/categories/npm/"/>
    
    
      <category term="Npm" scheme="http://yoursite.com/tags/Npm/"/>
    
  </entry>
  
  <entry>
    <title>koa</title>
    <link href="http://yoursite.com/2018/10/22/koa/koa-middleware/"/>
    <id>http://yoursite.com/2018/10/22/koa/koa-middleware/</id>
    <published>2018-10-22T06:26:27.000Z</published>
    <updated>2018-10-22T07:00:19.634Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>每周npm模块源码解读已经写了8周了，个人觉得这种叙述方式对于没看过源码的读者不太友好。</p><p>而大部分的读者也又不会去看这些模块的源码(根本没有读者)。</p><h3 id="koa简介"><a href="#koa简介" class="headerlink" title="koa简介"></a>koa简介</h3><p>Koa是一个新的web框架，由Express幕后的原班人马打造，致力于成为web应用和API开发领域中的一个更小、更富有表现力、更健壮的基石。</p><p>通过利用async函数，Koa帮你丢弃回调函数，并有力地增强错误处理。 Koa并没有捆绑任何中间件，而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。</p><h3 id="市场"><a href="#市场" class="headerlink" title="市场"></a>市场</h3><p>并且很多公司在Koa的基础上进行更深层次的包装，比如egg.js，think.js等。</p><h3 id="打算"><a href="#打算" class="headerlink" title="打算"></a>打算</h3><p>换种更友好的叙述方式来完成Koa中间件系列，会从中间件中挑选不同类型的一种较知名的模块来分析。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>有26种不同类型的中间件，也就是26篇。另外加10篇其他的，计划完成36篇。</p><p>计划今年过年前完成，也就是2019年2月4日截止。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="Koa" scheme="http://yoursite.com/categories/Koa/"/>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
</feed>
