<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>青蛙蛤蟆兽</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-24T13:37:29.749Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yupeilin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Koa系列-File Serving：koa-send</title>
    <link href="http://yoursite.com/2018/12/24/koa/koa-send/"/>
    <id>http://yoursite.com/2018/12/24/koa/koa-send/</id>
    <published>2018-12-24T01:59:35.000Z</published>
    <updated>2018-12-24T13:37:29.749Z</updated>
    
    <content type="html"><![CDATA[<p>一个例子，具体的用法可以看文档：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> send(ctx, ctx.path, &#123; <span class="attr">root</span>: __dirname + <span class="string">'/public'</span> &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>选项中的 <code>root</code> 表示以哪个文件夹作为静态资源文件夹，若不传则以当前文件夹为静态资源文件夹。</p><p>函数 <code>decode</code> 用于解码由 <code>encodeURIComponent</code> 方法或者其它类似方法编码的部分统一资源标识符（URI）。</p><p>选项中的 <code>hidden</code> 来隐藏 <code>.xx</code> 格式的文件，避免显示它们。</p><p><code>gizp</code> , <code>brotli</code> 以及 <code>extensions</code> 用来传输特殊压缩格式的文件。</p><p>接着去判断该请求路径的文件，是否存在。存在的话，并且 <code>options.index</code> 是存在，则自动打开该文件。</p><p>并且可以去设置响应头，但 <code>setHeaders</code> 一定得为函数。</p><p>最后用流的方式传输文件。</p><p>在其中可以去设置响应头 <code>Last-Modified</code> 和 <code>Cache-Control</code>。</p><p>总体来说，继续学习吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;一个例子，具体的用法可以看文档：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span
        
      
    
    </summary>
    
      <category term="Koa" scheme="http://yoursite.com/categories/Koa/"/>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>每周npm模块源码解读：delegates</title>
    <link href="http://yoursite.com/2018/12/22/npm/delegates/"/>
    <id>http://yoursite.com/2018/12/22/npm/delegates/</id>
    <published>2018-12-22T08:11:05.000Z</published>
    <updated>2018-12-24T01:58:53.618Z</updated>
    
    <content type="html"><![CDATA[<p><strong>周2018.12.17 ~ 2018.12.23</strong></p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>模块名：<code>delegates</code></p><p>github: <a href="https://github.com/tj/node-delegates" target="_blank" rel="noopener">https://github.com/tj/node-delegates</a></p><p>描述：方法和访问器委托的工具</p><p>适合人群：至少看过一遍源码</p><a id="more"></a><h5 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h5><p>用函数的形式调用，实则是用 <code>new</code> 来实例。</p><p><code>Delegate(proto, target)</code> ：实例构造函数 <code>Delegator</code> 。</p><p><code>Delegate.auto(proto, targetProto, targetProp)</code> ：实例构造函数 <code>Delegator</code> ,然后使用 <code>Object.getOwnPropertyNames</code> 来得到 <code>targetProto</code> 的自身属性的属性名（包括不可枚举但不包括Symbol值作为名称的属性）。将通过 <code>Object.getOwnPropertyDescriptor</code> 得到 <code>taegetProto</code> 的每个属性的描述符，接着是数据描述符还是存取描述符，进行相应的操作。</p><p><code>Delegate#method(name)</code> ：将 <code>target</code> 的此方法挂载到 <code>proto</code> 上。</p><p><code>Delegate#getter(name)</code> ：使用 <code>__defineGetter__</code> 将属性挂载到 <code>proto</code> 上。使用 <code>Object.defineProperty</code></p><p><code>Delegate#setter(name)</code> ：使用 <code>__defineSetter__</code> 将属性挂载到 <code>proto</code> 上。</p><p><code>Delegate#access(name)</code> ：连着使用 <code>getter</code> 和 <code>setter</code>。</p><p><code>Delegate#fluent(name)</code> ：判断调用时，参数是否是 <code>undefined</code> ,是则返回该属性对应值，不是则去设置该属性的值。</p><h5 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h5><p>学习了，学习了，结合 <code>koa</code> 的 <code>context</code> 可以更加了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;周2018.12.17 ~ 2018.12.23&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;模块名：&lt;code&gt;delegates&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/tj/node-delegates&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/tj/node-delegates&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;描述：方法和访问器委托的工具&lt;/p&gt;
&lt;p&gt;适合人群：至少看过一遍源码&lt;/p&gt;
    
    </summary>
    
      <category term="npm" scheme="http://yoursite.com/categories/npm/"/>
    
    
      <category term="NPM" scheme="http://yoursite.com/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>Koa系列-Documentation：koa-joi-swagger</title>
    <link href="http://yoursite.com/2018/12/14/koa/koa-joi-swagger/"/>
    <id>http://yoursite.com/2018/12/14/koa/koa-joi-swagger/</id>
    <published>2018-12-14T03:18:51.000Z</published>
    <updated>2018-12-14T03:46:40.564Z</updated>
    
    <content type="html"><![CDATA[<p>这个中间件主要是用来搭建 api 文档管理的网站，用到了 <code>swagger-ui</code> 作为页面 UI， <code>joi</code> 用做管理 js 对象的验证器。</p><p>首先是用 <code>joi.extend</code> 扩展了对象，字符和数字新的 joi 实例。</p><p>然后选择是用 v3 还是 v2 的 <code>swagger-ui</code> ，得到最终渲染的模板 html。</p><p>最后对描述 api 的内容进行转化，生成验证规则，得到最终的 api 文档管理。</p><p>这个中间件挺老了，并且用法也不太方便，而且现在市面上也出现了挺多优秀的 api 文档管理系统。</p><p>所以就大概就了解其实现思路。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;这个中间件主要是用来搭建 api 文档管理的网站，用到了 &lt;code&gt;swagger-ui&lt;/code&gt; 作为页面 UI， &lt;code&gt;joi&lt;/code&gt; 用做管理 js 对象的验证器。&lt;/p&gt;
&lt;p&gt;首先是用 &lt;code&gt;joi.extend&lt;/code&gt;
        
      
    
    </summary>
    
      <category term="Koa" scheme="http://yoursite.com/categories/Koa/"/>
    
    
      <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>每周npm模块源码解读：get-port</title>
    <link href="http://yoursite.com/2018/12/10/npm/get-port/"/>
    <id>http://yoursite.com/2018/12/10/npm/get-port/</id>
    <published>2018-12-10T15:11:15.000Z</published>
    <updated>2018-12-22T08:13:01.645Z</updated>
    
    <content type="html"><![CDATA[<p><strong>周2018.12.10 ~ 2018.12.16</strong></p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>模块名：<code>get-port</code></p><p>github: <a href="https://github.com/sindresorhus/get-port" target="_blank" rel="noopener">https://github.com/sindresorhus/get-port</a></p><p>描述：随即找到一个可用的端口或则检查端口是否可以使用</p><p>适合人群：至少看过一遍源码</p><a id="more"></a><h5 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h5><p>首先根据 <code>option</code> 来判断是判断端口是否可用还是随机得到一个可用的端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = options =&gt; options ?</span><br><span class="line">  getPort(options).catch(() =&gt; getPort(&#123;port: 0&#125;)) :</span><br><span class="line">  getPort(&#123;port: 0&#125;);</span><br></pre></td></tr></table></figure><p><code>options.port</code> 的类型得为数字或者数组，如果不是，也可以进行 <code>getPort({port: 0}))</code> 。</p><p>但会出现一个错误即是 <code>UnhandledPromiseRejectionWarning</code> 。</p><p>最后是通过函数<code>isAvailable</code> 来得到或者判断端口可否使用。</p><p>函数 <code>getPort</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getPort = <span class="function">(<span class="params">options = &#123;&#125;</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options.port === <span class="string">'number'</span>) &#123;</span><br><span class="line">    options.port = [options.port];</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;!-- 操作端口号 --&gt;</span><br><span class="line">  options.port.reduce(<span class="function">(<span class="params">seq, port</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> seq.catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> isAvailable(<span class="built_in">Object</span>.assign(&#123;&#125;, options, &#123;port&#125;))</span><br><span class="line">        .then(<span class="function"><span class="params">port</span> =&gt;</span> port)</span><br><span class="line">        .catch(<span class="built_in">Promise</span>.reject.bind(<span class="built_in">Promise</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="built_in">Promise</span>.reject()).then(resolve).catch(reject);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h5><p>学习了node模块net的使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;周2018.12.10 ~ 2018.12.16&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;模块名：&lt;code&gt;get-port&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/sindresorhus/get-port&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sindresorhus/get-port&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;描述：随即找到一个可用的端口或则检查端口是否可以使用&lt;/p&gt;
&lt;p&gt;适合人群：至少看过一遍源码&lt;/p&gt;
    
    </summary>
    
      <category term="npm" scheme="http://yoursite.com/categories/npm/"/>
    
    
      <category term="NPM" scheme="http://yoursite.com/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>每周npm模块源码解读：inherits</title>
    <link href="http://yoursite.com/2018/12/06/npm/inherits/"/>
    <id>http://yoursite.com/2018/12/06/npm/inherits/</id>
    <published>2018-12-06T06:02:14.000Z</published>
    <updated>2018-12-22T08:13:11.787Z</updated>
    
    <content type="html"><![CDATA[<p><strong>周2018.12.3 ~ 2018.12.9</strong></p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>模块名：<code>inherits</code></p><p>github: <a href="https://github.com/isaacs/inherits" target="_blank" rel="noopener">https://github.com/isaacs/inherits</a></p><p>描述：一种适用于node和浏览器的继承方法</p><p>适合人群：至少看过一遍源码</p><a id="more"></a><h5 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h5><p>首先是 <code>require(&#39;util&#39;)</code> ,判断 <code>util.inherits</code> 是否为函数（判断是否在node环境），如果是，用此方法。</p><p>如果不是，throw错误，转而使用在浏览器中的继承方法。</p><p>一种是以 <code>Object.create</code> 实现继承（寄生组合式继承），另一种是判断 <code>Object.create</code> 不能使用时的垫片方法，实现 <code>Object.create</code> 的使用（寄生组合式继承）。</p><p><strong>js不同继承方式原理</strong></p><h6 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h6><p>利用原型让一个引用类型继承另一个引用类型的属性和方法</p><h6 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h6><p>在子类型构造函数的内部调用超类型构造函数</p><h6 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h6><p>使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承</p><h6 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h6><p>借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型</p><h6 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h6><p>创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象</p><h6 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h6><p>不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型 的原型</p><h5 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h5><p>可以从中学习javascript的继承方式</p><h5 id="附-util-inherits-源码："><a href="#附-util-inherits-源码：" class="headerlink" title="附 util.inherits 源码："></a>附 <code>util.inherits</code> 源码：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">ctor, superCtor</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctor === <span class="literal">undefined</span> || ctor === <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ERR_INVALID_ARG_TYPE(<span class="string">'ctor'</span>, <span class="string">'Function'</span>, ctor);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (superCtor === <span class="literal">undefined</span> || superCtor === <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ERR_INVALID_ARG_TYPE(<span class="string">'superCtor'</span>, <span class="string">'Function'</span>, superCtor);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (superCtor.prototype === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ERR_INVALID_ARG_TYPE(<span class="string">'superCtor.prototype'</span>,</span><br><span class="line">      <span class="string">'Function'</span>, superCtor.prototype);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(ctor, <span class="string">'super_'</span>, &#123;</span><br><span class="line">    value: superCtor,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(ctor.prototype, superCtor.prototype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;周2018.12.3 ~ 2018.12.9&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;模块名：&lt;code&gt;inherits&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;github: &lt;a href=&quot;https://github.com/isaacs/inherits&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/isaacs/inherits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;描述：一种适用于node和浏览器的继承方法&lt;/p&gt;
&lt;p&gt;适合人群：至少看过一遍源码&lt;/p&gt;
    
    </summary>
    
      <category term="npm" scheme="http://yoursite.com/categories/npm/"/>
    
    
      <category term="NPM" scheme="http://yoursite.com/tags/NPM/"/>
    
  </entry>
  
</feed>
